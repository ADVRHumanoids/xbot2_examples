#ifndef ROCKET_DEVICE_H
#define ROCKET_DEVICE_H

#include <xbot2/hal/device.h>
#include <xbot2/client_server/client_manager.h>

#include "rocket_packet.h"

/* This file defines the class that implements the client side
 * of the link between the robot (in simulation, our rocket gazebo plugin)
 * and the xbot2 framework.
 *
 * If there is no client-side logic to be implemented, this can be
 * pure boilerplate code that can be autogenerated.
 *
 * However, there are some additional possibilities, as detailed below.
 *
 */

namespace XBot { namespace Hal {

/**
 * @brief The RocketInstance class, by inheriting DeviceInstanceTpl,
 * automatically connects the rx and tx data for a single rocket device
 * to the xbot2 framework.
 *
 * Optionally, the developer can
 *  - override sense_impl(), to customize how the incoming rx data
 *    (from the robot or gazebo) are propagated to the framework;
 *    for instance, one could apply a filter to mitigate noise in
 *    the measurments
 *  - override move_impl(), to customize how the tx from the framework
 *    are broadcast to gazebo (or the robot); in the following example,
 *    we apply a simple timout to the thrust reference so that, if no
 *    command is received for 2 seconds, the thrust ref is set to zero.
 *    Hard limits or filtering can also be implemented.
 */
class RocketInstance : public DeviceInstanceTpl<RocketPacket::Rx,
                                                RocketPacket::Tx>
{

public:

    RocketInstance(DeviceInstanceInfo devinfo);

    /**
     * @brief move_impl allows to override the tx data from
     * the framework before it's actually sent to the device
     */
    bool move_impl() override;

    /**
     * @brief sense_impl allows to override the rx data from
     * the device before it's actually sent to the framework
     * @return if return false, rx is not actually sent to
     * the framework!
     */
    bool sense_impl() override;

private:

    std::chrono::nanoseconds _timeout;
};

/**
 * @brief The RocketDev class implements the client side
 * for all rocket device instances. If the protocol in use is
 * xbot2's client-server protocol, this is pure boilerplate
 * code that can be autogenerated. Otherwise, the user must
 * write the code to connect to the remote device.
 */
class RocketDev : public DeviceTpl<RocketInstance>
{

public:

    typedef DeviceTpl<RocketInstance> BaseType;

    RocketDev(std::string name,
              std::vector<DeviceInstanceInfo> devinfo);

    bool sense() override;

    bool move() override;

private:

    bool _srv_alive;

    ClientManager::UniquePtr _cli;

};

}
}


#endif // ROCKET_DEVICE_H
